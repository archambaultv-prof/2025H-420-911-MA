---
sidebar_position: 2
sidebar_label: Client-Serveur
description: Client-Serveur
---

# ğŸ“§ Communication interprocessus : Client et Serveur

## ğŸ¯ Objectif pÃ©dagogique

- Comprendre les mÃ©canismes de communication interprocessus (IPC) Ã  l'aide de sockets.
- CrÃ©er un serveur et un client en Python.
- Identifier le rÃ´le du systÃ¨me d'exploitation dans la gestion des connexions rÃ©seau.

## ğŸ“œ Ã‰noncÃ©

Dans cet exercice, vous allez crÃ©er une simple application de communication
entre un **client** et un **serveur** en utilisant des **sockets** en Python.

### ğŸ”§ Ã‰tape 1 â€“ CrÃ©er un serveur simple

Un serveur :

- Ouvre une Â« porte Â» (appelÃ©e un **port**) sur votre ordinateur.
- Attend qu'un client s'y connecte.
- ReÃ§oit les messages du client.

#### Code du serveur

CrÃ©ez un fichier appelÃ© `serveur.py` et copiez le code suivant :

```python
import socket

# CrÃ©e un socket TCP
serveur = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# L'adresse IP et le port Ã  utiliser
hote = 'localhost'
port = 12345

# Lier le socket Ã  l'adresse
serveur.bind((hote, port))

# Ã‰coute jusqu'Ã  1 connexion
serveur.listen(1)
print("[Serveur] En attente de connexion...")

# Accepter la connexion
connexion, adresse = serveur.accept()
print(f"[Serveur] Connexion de {adresse}")

# RÃ©ception des messages
while True:
    message = connexion.recv(1024).decode()
    if message.lower() == "exit":
        print("[Serveur] Fin de la communication.")
        break
    print(f"[Client] {message}")

# Fermer les connexions
connexion.close()
serveur.close()
```

#### Test

Ce programme ne fait rien tant qu'un client ne s'est pas connectÃ©. DÃ©marrez le serveur avec la commande :

```bash
python serveur.py
```

et connectez-vous avec votre navigateur web en allant Ã  `http://localhost:12345`.

:::tip

Vous pouvez arrÃªter le serveur en appuyant sur `Ctrl+C` dans le terminal.

:::

### ğŸ’¬ Ã‰tape 2 â€“ CrÃ©er un client

Un client :

* Se connecte Ã  un serveur (ici via `localhost` et le port).
* Envoie des messages que vous tapez dans la console.

#### 2.1 Code du client

CrÃ©ez un fichier `client.py` :

```python
import socket

# CrÃ©e un socket TCP
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Se connecter au serveur
client.connect(('localhost', 12345))
print("[Client] ConnectÃ© au serveur. Tapez vos messages :")

# Lire et envoyer les messages
while True:
    message = input(">>> ")
    client.sendall(message.encode())
    if message.lower() == "exit":
        break

# Fermer la connexion
client.close()
```

#### 2.2 Test

1. Dans un terminal : lancez `python serveur.py`
2. Dans un **autre terminal** : lancez `python client.py`
3. Ã‰changez quelques messages.
4. Tapez `exit` pour arrÃªter.


### ğŸ” Ã‰tape 3 â€“ Communication dans les deux sens

Actuellement, seul le client parle et le serveur Ã©coute. Nous allons maintenant
permettre au **serveur de rÃ©pondre**.

#### 3.1 Utiliser `threading` pour Ã©couter et Ã©crire en mÃªme temps

CrÃ©ez un fichier appelÃ© `serveur2.py` et copiez le code suivant :

```python
import socket
import threading

def recevoir(connexion):
    while True:
        try:
            message = connexion.recv(1024).decode()
            if not message or message.lower() == "exit":
                print("[Client] a quittÃ© la conversation.")
                print("[Serveur >>>] ", end="", flush=True)
                break
            print(f"[Client] {message}")
            print("[Serveur >>>] ", end="", flush=True)
        except:  # noqa: E722
            break

def envoyer(connexion):
    while True:
        try:
            message = input("[Serveur >>>] ")
            connexion.sendall(message.encode())
            if message.lower() == "exit":
                break
        except:  # noqa: E722
            break

# CrÃ©ation du serveur
serveur = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
serveur.bind(('localhost', 12345))
serveur.listen(1)

print("[Serveur] En attente de connexion...")
connexion, adresse = serveur.accept()
print(f"[Serveur] ConnectÃ© Ã  {adresse}")

# DÃ©marrage des threads
thread1 = threading.Thread(target=recevoir, args=(connexion,))
thread2 = threading.Thread(target=envoyer, args=(connexion,))
thread1.start()
thread2.start()

thread1.join()
thread2.join()
connexion.close()
serveur.close()
```

CrÃ©ez un fichier appelÃ© `client2.py` et copiez le code suivant :

```python
import socket
import threading

def recevoir(sock):
    while True:
        message = sock.recv(1024).decode()
        if message.lower() == "exit":
            print("[Serveur] a quittÃ© la conversation.")
            print("[Client >>>] ", end="", flush=True)
            break
        print(f"[Serveur] {message}")
        print("[Client >>>] ", end="", flush=True)

def envoyer(sock):
    while True:
        message = input("[Client >>>] ")
        sock.sendall(message.encode())
        if message.lower() == "exit":
            break

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect(('localhost', 12345))
print("[Client] ConnectÃ© au serveur.")

# DÃ©marrage des threads
thread1 = threading.Thread(target=recevoir, args=(client,))
thread2 = threading.Thread(target=envoyer, args=(client,))
thread1.start()
thread2.start()

thread1.join()
thread2.join()
client.close()
```

#### âœ… RÃ©sultat attendu

1. Lancez `serveur2.py` dans un terminal.
2. Lancez `client2.py` dans un autre.
3. Essayez dâ€™Ã©changer des messages dans les deux sens.
4. Fermez proprement avec `exit`.

![Exemple de communication entre client et serveur](/img/exo_client_serveur.png)

### ğŸ“ Ã‰tape 4 â€“ Le systÃ¨me d'exploitation

Le systÃ¨me d'exploitation joue un rÃ´le crucial dans la gestion des connexions
rÃ©seau. Il gÃ¨re les ressources, les ports, et assure que les donnÃ©es sont
envoyÃ©es et reÃ§ues correctement. Il en est de mÃªme pour les threads, qui permettent
d'exÃ©cuter plusieurs tÃ¢ches en parallÃ¨le, comme Ã©couter et envoyer des messages
en mÃªme temps.

RÃ©pondez aux questions suivantes :

- Dans le code du serveur et du client, Ã  quel moment le systÃ¨me
  d'exploitation est-il impliquÃ© ?
- Est-ce que les threads sont gÃ©rÃ©s par le systÃ¨me d'exploitation (OS thread) ou par Python (application thread) ?
- Pourquoi est-il important de fermer les connexions proprement ?
- Que se passe-t-il si vous essayez de lancer le serveur plusieurs fois sur le mÃªme port sans le fermer ?
- Que se passe-t-il si vous essayez de lancer le client avant le serveur ?